//! # rsc-coverage
//!
//! Code coverage tooling for RustScript. This crate provides:
//!
//! - **Data collection**: Thread-local runtime collector for coverage probes
//! - **Source mapping**: Links probe IDs to source file locations
//! - **Report generation**: Coverage reports with line, function, and branch metrics
//! - **Multiple formats**: LCOV, JSON, and HTML reporters
//!
//! ## Quick Start
//!
//! ```ignore
//! use rsc_coverage::{collector, CoverageMap, CoverageReport, reporters::LcovReporter, CoverageReporter};
//!
//! // Enable coverage collection
//! collector::enable();
//!
//! // ... run your instrumented code ...
//!
//! // Export collected data
//! let data = collector::export_coverage();
//!
//! // Load the coverage map (generated by the compiler)
//! let map = CoverageMap::from_json(coverage_map_json)?;
//!
//! // Generate a report
//! let report = CoverageReport::from_map_and_data(&map, &data);
//!
//! // Output in LCOV format
//! let reporter = LcovReporter::new();
//! let lcov_output = reporter.report(&[report])?;
//! ```
//!
//! ## Runtime Integration
//!
//! The collector exports `__coverage_hit` as a C function that can be imported
//! by WASM modules to record coverage hits at runtime.
//!
//! ## Report Formats
//!
//! - **LCOV**: Standard format for codecov, coveralls, and IDE integrations
//! - **JSON**: Machine-readable format for custom tooling
//! - **HTML**: Interactive reports with source highlighting

pub mod collector;
pub mod data;
pub mod error;
pub mod map;
pub mod report;
pub mod reporter;
pub mod reporters;

// Re-export main types at crate root
pub use data::{CoverageData, ProbeHit, probe_kind};
pub use error::{CoverageError, Result};
pub use map::{CoverageMap, CoverageMapSet, FunctionInfo, ProbeLocation};
pub use report::{
    BranchCoverage, CoverageReport, CoverageSummary, FunctionCoverage, LineCoverage,
    aggregate_summaries, generate_reports,
};
pub use reporter::CoverageReporter;
pub use reporters::{HtmlReporter, JsonReporter, LcovReporter};

/// Prelude module for convenient imports.
pub mod prelude {
    pub use crate::collector::{
        disable, enable, export_coverage, is_enabled, reset, CoverageGuard,
    };
    pub use crate::data::{CoverageData, ProbeHit, probe_kind};
    pub use crate::map::{CoverageMap, CoverageMapSet};
    pub use crate::report::{CoverageReport, CoverageSummary, aggregate_summaries, generate_reports};
    pub use crate::reporter::CoverageReporter;
    pub use crate::reporters::{HtmlReporter, JsonReporter, LcovReporter};
    pub use crate::{CoverageError, Result};
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_full_workflow() {
        // Enable collection
        collector::enable();
        collector::reset();

        // Simulate coverage hits
        collector::record_hit(1, probe_kind::LINE);
        collector::record_hit(2, probe_kind::LINE);
        collector::record_hit(10, probe_kind::FUNCTION_ENTRY);

        // Export data
        let data = collector::export_coverage();
        assert_eq!(data.get_hit_count(1), 1);
        assert_eq!(data.get_hit_count(2), 1);
        assert_eq!(data.get_hit_count(10), 1);

        // Create a coverage map
        let mut map = CoverageMap::new("test.rsx".to_string());
        map.add_probe(
            1,
            ProbeLocation {
                line: 10,
                column: 1,
                kind: probe_kind::LINE,
                function: Some("main".to_string()),
                file: "test.rsx".to_string(),
            },
        );
        map.add_probe(
            2,
            ProbeLocation {
                line: 11,
                column: 1,
                kind: probe_kind::LINE,
                function: Some("main".to_string()),
                file: "test.rsx".to_string(),
            },
        );
        map.add_probe(
            10,
            ProbeLocation {
                line: 10,
                column: 1,
                kind: probe_kind::FUNCTION_ENTRY,
                function: Some("main".to_string()),
                file: "test.rsx".to_string(),
            },
        );
        map.add_function(FunctionInfo {
            name: "main".to_string(),
            start_line: 10,
            end_line: 15,
            entry_probe: 10,
        });

        // Generate report
        let report = CoverageReport::from_map_and_data(&map, &data);

        assert_eq!(report.summary.total_lines, 2);
        assert_eq!(report.summary.covered_lines, 2);
        assert_eq!(report.summary.total_functions, 1);
        assert_eq!(report.summary.covered_functions, 1);

        // Test LCOV output
        let lcov = LcovReporter::new();
        let lcov_output = lcov.report(&[report.clone()]).unwrap();
        assert!(lcov_output.contains("SF:test.rsx"));
        assert!(lcov_output.contains("LH:2"));

        // Test JSON output
        let json = JsonReporter::new();
        let json_output = json.report(&[report.clone()]).unwrap();
        let parsed: serde_json::Value = serde_json::from_str(&json_output).unwrap();
        assert!(parsed.get("summary").is_some());

        // Test HTML output
        let html = HtmlReporter::new();
        let html_output = html.report(&[report]).unwrap();
        assert!(html_output.contains("<!DOCTYPE html>"));

        collector::disable();
    }

    #[test]
    fn test_prelude_imports() {
        use crate::prelude::*;

        let _guard = CoverageGuard::new();
        assert!(is_enabled());
    }
}
